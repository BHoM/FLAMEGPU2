# Include common rules.
# Actually dont as the c Warning levels are too damn high
#include(../../cmake/common.cmake)
# Just include cuda_arch to suppress CMAKE 3.18 warnings on windows (where nvcc is used even when not neccesary)
get_filename_component(FLAMEGPU_ROOT ${CMAKE_CURRENT_SOURCE_DIR}/../../ REALPATH)
include(${FLAMEGPU_ROOT}/cmake/cuda_arch.cmake)

STRING(TOLOWER "${CMAKE_SYSTEM_NAME}" CMAKE_SYSTEM_NAME_LOWER)

# Python module name (must match module name in swig input *.i file)
SET(PYTHON_MODULE_NAME pyflamegpu)

# TODO: Somehow incorporate $<CONFIG> for multi configuration builds of library
SET(PYTHON_LIB_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib/${CMAKE_SYSTEM_NAME_LOWER}-x64/python)
# Python library temp directory (for autogenerated swig files etc.)
SET(PYTHON_LIB_TEMP_DIRECTORY ${CMAKE_BINARY_DIR}/swig/python/${CMAKE_BUILD_TYPE})
# set input file name (TODO: consistency of library names e.g. flamegpu into flamegpu2)
SET(SWIG_INPUT_FILE_NAME flamegpu)

#########################################
## Swig input processing and building  ##
#########################################

# setup properties of swig input file
set_property(SOURCE ${SWIG_INPUT_FILE_NAME}.i PROPERTY CPLUSPLUS ON)
set_property(SOURCE ${SWIG_INPUT_FILE_NAME}.i PROPERTY SWIG_MODULE_NAME ${PYTHON_MODULE_NAME})
#set_property(SOURCE ${SWIG_INPUT_FILE_NAME}.i PROPERTY SWIG_FLAGS "-builtin")

# Add swig module
swig_add_library(${PYTHON_MODULE_NAME}
	TYPE SHARED
	#TYPE STATIC
	LANGUAGE python 
	OUTPUT_DIR ${PYTHON_LIB_TEMP_DIRECTORY}/${PYTHON_MODULE_NAME}
	SOURCES ${SWIG_INPUT_FILE_NAME}.i)

# configure wrapper code to build with cuda compiler
set_source_files_properties(${PYTHON_LIB_TEMP_DIRECTORY}/${PYTHON_MODULE_NAME}/${SWIG_INPUT_FILE_NAME}PYTHON_wrap.cxx PROPERTIES LANGUAGE CUDA)

# use the target include directories
set_property(TARGET ${PYTHON_MODULE_NAME} PROPERTY SWIG_USE_TARGET_INCLUDE_DIRECTORIES ON)
# needs to have RDC enable for the project
set_property(TARGET ${PYTHON_MODULE_NAME} PROPERTY CUDA_SEPARABLE_COMPILATION ON)
# Suppress warnings during compilation of SWIG generated PYTHON_wrap.cxx
set(CMAKE_CUDA_FLAGS "${CMAKE_CUDA_FLAGS} -Xcudafe --diag_suppress=\"declared_but_not_referenced\"")
# set bigobj property for windows compiler (needed due to the sheer size of the generated swig file: https://www.reddit.com/r/AbsoluteUnits/)
if(MSVC)
	set(CMAKE_CUDA_FLAGS "${CMAKE_CUDA_FLAGS} -Xcompiler /bigobj")
endif()
# set include directories for module build
target_include_directories(${PYTHON_MODULE_NAME}
  PRIVATE
  ../../include
  ${Python3_INCLUDE_DIRS}
  )
  
# link with the static flamegpu and cuda libraries
target_link_libraries(${PYTHON_MODULE_NAME} PRIVATE flamegpu2 cuda)
# Variable PYTHON_LIBRARIES can contains keyword `optimized`
# which won't be interpreted inside a generator expression.
# i.e. we can't use: $<$<PLATFORM_ID:Windows>:${PYTHON_LIBRARIES}>
# see: https://cmake.org/cmake/help/git-stage/command/target_link_libraries.html#command:target_link_libraries
if(MSVC)
  target_link_libraries(${PYTHON_MODULE_NAME} PRIVATE ${Python3_LIBRARIES} flamegpu2 cuda)
endif()


#######################
## Python Packaging  ##
#######################
# configure the python setup.py and __init__.py files for packaging and output to the final lib output folder
configure_file(
	setup.py.in
	${PYTHON_LIB_TEMP_DIRECTORY}/setup.py.in
	@ONLY)
file(GENERATE
	OUTPUT ${PYTHON_LIB_OUTPUT_DIRECTORY}/setup.py
	INPUT ${PYTHON_LIB_TEMP_DIRECTORY}/setup.py.in)
configure_file(
	__init__.py.in
	${PYTHON_LIB_TEMP_DIRECTORY}/__init__.py.in
	@ONLY)
file(GENERATE
	OUTPUT ${PYTHON_LIB_OUTPUT_DIRECTORY}/${PYTHON_MODULE_NAME}/__init__.py
	INPUT ${PYTHON_LIB_TEMP_DIRECTORY}/__init__.py.in)

# Function to find if python module MODULE_NAME is available, if not then install it to the Python user install directory.
function(search_python_module MODULE_NAME)
  execute_process(
    COMMAND ${Python3_EXECUTABLE} -c "import ${MODULE_NAME}; print(${MODULE_NAME}.__version__) if hasattr(${MODULE_NAME}, '__version__') else print('Unknown');"
    RESULT_VARIABLE _RESULT
    OUTPUT_VARIABLE MODULE_VERSION
    ERROR_QUIET
    OUTPUT_STRIP_TRAILING_WHITESPACE
    )
  if(${_RESULT} STREQUAL "0")
    message(STATUS "Found python module: ${MODULE_NAME} (version \"${MODULE_VERSION}\")")
  else()
    message(WARNING "Can't find python module \"${MODULE_NAME}\", user install it using pip...")
    execute_process(
      COMMAND ${Python3_EXECUTABLE} -m pip install --upgrade --user ${MODULE_NAME}
      OUTPUT_STRIP_TRAILING_WHITESPACE
      )
  endif()
endfunction()

# Look for required python modules to build the python module
search_python_module(setuptools)
search_python_module(wheel)

# Configure and build the python package
# The file configurations above will already have output setup.py and __init__.py to the appropriate places and created the directory for the module
add_custom_command(TARGET ${PYTHON_MODULE_NAME} POST_BUILD
	# copy generated python file to library output location
	COMMAND ${CMAKE_COMMAND} -E copy ${PYTHON_LIB_TEMP_DIRECTORY}/${PYTHON_MODULE_NAME}/${PYTHON_MODULE_NAME}.py ${PYTHON_MODULE_NAME}
	# copy the compiled pyd file to library output location
	COMMAND ${CMAKE_COMMAND} -E copy $<TARGET_FILE:${PYTHON_MODULE_NAME}> ${PYTHON_MODULE_NAME}
	COMMAND ${Python3_EXECUTABLE} setup.py bdist_wheel
	# by products of the packaging
	BYPRODUCTS
		${PYTHON_MODULE_NAME}
		build
		dist
		${PYTHON_MODULE_NAME}.egg-info
		setup.py
	WORKING_DIRECTORY ${PYTHON_LIB_OUTPUT_DIRECTORY}
)


# CTEST todolist.:
# + Activate the venv instead of cheesing it byinvoking specific executables.
# + Add dependencies/fixtures to make sure tests are built before executed.
# + Windows.
# + byproducts for make clean?
# + Structure of cmakefiles / file strucutres. add_tests should not be in here really...
# + Add individual python tests if relevant flag is passed.
# + test lables
# + Split unit tests and rtc tests? 
# + Rename tests target to flamegpu2_tests?
# + Move tests/ to tests/flamegpu/
# + see how this works with VS.

message("@todo - Should really be activating the venv rather than cheesing it with executables... but need to figure out how that works with the shell...")

# Always build the virtual env / make it required rather than it being behind an implied option.
# Build Virtual Environment for python testing and install the packaged wheel
# Look for python module virtualenv
search_python_module(venv)
# Testing using a virtual environment
set(VENV_EXECUTABLE ${Python3_EXECUTABLE} -m venv)
set(VENV_DIR ${PYTHON_LIB_OUTPUT_DIRECTORY}/venv)
# Can't use find file, as it doesn't exist yet, so predict the location of python. This seems a little fragile...
# @todo - generate the venv at configure time, and install pytest at configure time, then install pyflamegpu at build time. 
if(NOT WIN32)
	set(VENV_PYTHON3_EXECUTABLE "${VENV_DIR}/bin/python")
	# This is a little fragile, but can't use find_file as it doesn't exist yet.
	set(VENV_SITE_PACKAGES "${VENV_DIR}/lib/python${Python3_VERSION_MAJOR}.${Python3_VERSION_MINOR}/site-packages/")
	seT(VENV_SITE_PACKAGES_PYTEST "${VENV_SITE_PACKAGES}/pytest")
	seT(VENV_SITE_PACKAGES_PYFLAMEGPU "${VENV_SITE_PACKAGES}/${PYTHON_MODULE_NAME}")
else()
	set(VENV_PYTHON3_EXECUTABLE "${VENV_DIR}/Scripts/python.exe")
	message(FATAL_ERROR "Need to set VENV_PYTEST_FILE on windows")
endif()

message("VENV_EXECUTABLE ${VENV_EXECUTABLE}")
message("VENV_DIR ${VENV_DIR}")
message("VENV_PYTHON3_EXECUTABLE ${VENV_PYTHON3_EXECUTABLE}")


# @todo byproducts so make clean works? 
# Add a custom command to create the virtual environment and install pyflamegpu into it (and pytest?)
add_custom_command(OUTPUT ${VENV_DIR}
	COMMAND ${VENV_EXECUTABLE} ${VENV_DIR}
	COMMENT "Creating python venv ${VENV_DIR}"
	WORKING_DIRECTORY ${PYTHON_LIB_OUTPUT_DIRECTORY}
)

# Add a custom command to install pyflamegpu into the venv, appending the command?
add_custom_command(OUTPUT ${VENV_SITE_PACKAGES_PYFLAMEGPU} 
	COMMAND ${VENV_PYTHON3_EXECUTABLE} -m pip install --force-reinstall --find-links=dist --no-index -U ${PYTHON_MODULE_NAME}
	DEPENDS pyflamegpu
	COMMENT "Installing pyflamegpu into the venv"
	WORKING_DIRECTORY ${PYTHON_LIB_OUTPUT_DIRECTORY}
)

if(BUILD_TESTS)
# Add a custom command to install pytest, if required.
	add_custom_command(OUTPUT ${VENV_SITE_PACKAGES_PYTEST} 
		COMMAND ${VENV_PYTHON3_EXECUTABLE} -m pip install pytest
		COMMENT "Installing pytest into the venv"
		WORKING_DIRECTORY ${PYTHON_LIB_OUTPUT_DIRECTORY}
	)
endif()


if(BUILD_TESTS)
	# Add a custom target pyflamegpu_venv which depends on pyflamegpu and the venv?
	add_custom_target(pyflamegpu_venv ALL
		DEPENDS ${VENV_DIR} ${VENV_SITE_PACKAGES_PYFLAMEGPU} ${VENV_SITE_PACKAGES_PYTEST}
	)

else()
	# Custom target that doesn't depend on pytest?
	add_custom_target(pyflamegpu_venv ALL
		DEPENDS ${VENV_DIR} ${VENV_SITE_PACKAGES_PYFLAMEGPU}
	)

endif()

# @todo - this doesn't work because files != target in this case? Don't really want to wrap again, hence double declaraiton above. Might be better to make a list of dependencies upfront then make the target...

# if(BUILD_TESTS)
# 	add_dependencies(pyflamegpu_venv ${VENV_SITE_PACKAGES_PYTEST})
# endif()

# The venv target depends on the pacakge.
# add_dependencies(pyflamegpu_venv pyflamegpu)




# set project folders (for better organisation in visual studio)
if (CMAKE_USE_FOLDERS)
  set_property(GLOBAL PROPERTY USE_FOLDERS ON)
  set_property(TARGET "${PYTHON_MODULE_NAME}" PROPERTY FOLDER "FLAMEGPU")
endif ()





################
# Python Tests #
################
# @todo - better structure for this. Most likley tests/swig/python/CMakeLists.txt and tests/flamegpu/CMakeLists.txt or similar (and the appropraite separation)

# If python swig is enabeld, and tests, add pytests to ctest

if(BUILD_SWIG_PYTHON)
	message("Add python ctest.")
	# @todo - make this better.
	get_filename_component(SWIG_TESTS_SOURCE_DIR  "${CMAKE_CURRENT_SOURCE_DIR}/../../tests/swig/python" REALPATH)
	# set(SWIG_TESTS_SOURCE_DIR "${CMAKE_CURRENT_SOURCE_DIR}/../../tests/swig/python")
	message("SWIG_TESTS_SOURCE_DIR ${SWIG_TESTS_SOURCE_DIR}")
	message("VENV_PYTHON3_EXECUTABLE ${VENV_PYTHON3_EXECUTABLE}")

    # Add the dependency for all_tests?
    add_dependencies(all_tests pyflamegpu_venv)

    # @todo make ctest depend on the venv somehow?

    if(USE_GTEST_DISCOVER)
        # Pytest doesn't use gtest discover, but we can map it to individual tests
		message(FATAL_ERROR "@todo - somehow find individual pytests? or atleast per file basis.")
		# @todo pytest --collect-only lists all the test
		# pytest --collect-only -k "test_agent_death_array"
		# This would need pytest at cmake configure time.
		# And a list of python files within cmake, not globbed incase new files are added as they wouldn't be detected.
		# Each discovered test would then need adding via add_test with an appropraite name, matching how gtest_discover works.


    else()
        # Otherwise just add the full python test suite as a single pytest invocation.
        # Do not use an absolute path to the python interpreter, as this will not be the one in the venv (venv doesn't exist at cmake configuration time)
        add_test(
            NAME python
            COMMAND ${VENV_PYTHON3_EXECUTABLE} -m pytest 
            WORKING_DIRECTORY ${SWIG_TESTS_SOURCE_DIR}
        )
    endif()


endif()
